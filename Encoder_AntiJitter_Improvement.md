# 旋转编码器防跳动算法改进说明

## 问题描述
原始的旋转编码器实现使用简单的边沿检测，容易产生"左右跳动"问题，这是由以下原因造成的：

1. **机械抖动** - 编码器内部触点弹跳
2. **简单边沿检测** - 只检测单个引脚变化，容易误判
3. **防抖时间不足** - 原始5ms防抖时间太短

## 解决方案

### 1. 改进的表格解码算法
实现了基于John Main研究的**Robust Rotary Encoder Reading**算法，该算法具有以下特点：

- **双重过滤机制**：
  - 第一层：有效转换过滤（16状态转换表）
  - 第二层：完整序列验证（检测完整的detent-to-detent转换）

- **特定序列检测**：
  - 顺时针完整序列：`0x17`
  - 逆时针完整序列：`0x2b`
  - 只有检测到完整序列才触发事件

### 2. 关键改进点

#### 转换表算法
```c
// 有效转换查找表 - 消除大部分机械噪声
static const int8_t rot_enc_table[] = {0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0};
```

#### 序列验证
```c
// 检测完整的旋转序列，确保可靠性
if ((encoder->store & 0xff) == 0x2b) {
    // 确认的逆时针旋转
} else if ((encoder->store & 0xff) == 0x17) {
    // 确认的顺时针旋转
}
```

#### 防抖优化
- 将防抖时间从5ms减少到2ms，提高响应性
- 依靠算法过滤而不是时间延迟

### 3. 算法优势

1. **极高的噪声免疫力** - 能处理质量很差的编码器
2. **无误触发** - 双重验证确保每次事件都是真实的
3. **高响应性** - 减少防抖延迟，提高用户体验
4. **向后兼容** - 保持原有API接口不变

### 4. 测试建议

在CubeMX中配置GPIO中断：

1. **PB12 (CW)** - 配置为GPIO_EXTI12，下降沿触发
2. **PB13 (CCW)** - 配置为GPIO_EXTI13，下降沿触发  
3. **PB14 (Button)** - 配置为GPIO_EXTI14，下降沿触发

中断优先级建议设置为较高优先级（如PreemptionPriority = 1）。

### 5. 监控输出

通过串口可以观察到：
- 按键事件：按下、释放、点击、长按
- 编码器事件：包含步数、总计数、实际位置
- 系统统计：运行时间、事件计数等

### 6. 性能表现

经过优化后的算法应该能够：
- 消除99%以上的误触发
- 即使是廉价编码器也能稳定工作
- 快速旋转时不丢失事件
- 慢速精确控制时每个detent都能准确检测

## 参考资料

本实现基于以下权威资料：
- John Main的"Robust Rotary Encoder Reading"算法
- Best Microcontroller Projects网站的详细分析
- 实际测试验证的噪声过滤技术

该算法已在多种Arduino项目中得到验证，现移植到STM32平台并针对实时性能进行了优化。
